package com.travelbank.knit.schedulers;

import java.util.concurrent.Callable;

/**
 * This class is only used by {@link com.travelbank.knit.InternalModel}s generated by KnitProcessor.
 * It provides a stubbing pattern for handling {@link SchedulerInterface} tasks.
 *
 * @author Omer Ozer
 */

public class KnitTaskFlow {

    /**
     * Entry point of the stub. Entry always start with a {@link Callable} because {@link Runnable} don't generate results.
     * @param callable {@link Callable} that contains the task the generate the result to be sent to the {@link Consumer}.
     * @param <T> type of the result generated by the {@link Callable} task.
     * @return initial instance for {@link ScheduleFlower}
     */
    public static<T> ScheduleFlower<T> create(Callable<T> callable){
        return new ScheduleFlower<T>().task(callable);
    }

    /**
     * Inner class that handles all stubbing.
     * @param <T>
     */
    public static class ScheduleFlower<T>{

        /**
         * {@link Callable} task that will be handled.
         */
        private Callable<T> task;

        /**
         * {@link SchedulerInterface} that will handle the task.
         */
        private SchedulerInterface on;

        /**
         * {@link SchedulerInterface} that will receive the results from {@link Callable} task.
         */
        private SchedulerInterface target;

        /**
         * Stub method to accept {@link Callable}.
         * @param callable {@link Callable} task.
         * @return Stub
         */
        public ScheduleFlower task(Callable<T> callable){
            this.task = callable;
            return this;
        }

        /**
         * Stub method to accept {@link SchedulerInterface} to run the task on.
         * @param scheduler {@link SchedulerInterface} to run the task on.
         * @return
         */
        public ScheduleFlower runOn(SchedulerInterface scheduler){
            this.on = scheduler;
            return this;
        }

        /**
         * Stub method to accept {@link SchedulerInterface} to run the consumer on.
         * @param scheduler {@link SchedulerInterface} to run the consumer on.
         * @return
         */
        public ScheduleFlower consumeOn(SchedulerInterface scheduler){
            this.target = scheduler;
            return this;
        }

        /**
         * Start method that ends stubbing by accepting the final piece of the Stub which is the {@link Consumer}
         * @param consumer {@link Consumer} that contains handling logic for the result from {@link Callable}
         */
        public void start(Consumer<T> consumer){
            this.on.setTargetAndConsumer(target,consumer);
            this.on.start();
            this.on.submit(task);
        }

    }

}
